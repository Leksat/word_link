<?php
/**
 * @file
 * This module allows users to replace previously defined words to the links.
 */

/**
 * Implements hook_permission().
 */
function word_link_permission() {
  return array(
    'view word link' => array(
      'title' => t('View Word Link'),
    ),
    'create word link' => array(
      'title' => t('Create Word Link'),
    ),
    'edit word link' => array(
      'title' => t('Edit Word Link'),
    ),
    'delete word link' => array(
      'title' => t('Delete Word Link'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function word_link_menu() {
  $items = array();

  $items['admin/config/content/word-link'] = array(
    'title' => 'Word Link',
    'description' => 'Administer Words Link',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_list_page_form'),
    'access arguments' => array('view word link'),
    'file' => 'word_link.admin.inc',
  );

  $items['admin/config/content/word-link/list'] = array(
    'title' => 'List',
    'description' => 'Words list',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_list_page_form'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'word_link.admin.inc',
  );

  $items['admin/config/content/word-link/configuration'] = array(
    'title' => 'Configuration',
    'description' => 'Set the preferences for Word Link module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'word_link.admin.inc',
    'weight' => 2,
  );

  $items['admin/config/content/word-link/add'] = array(
    'title' => 'Add new word',
    'description' => 'Add word',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_add_form'),
    'access arguments' => array('create word link'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'word_link.admin.inc',
  );

  $items['admin/config/content/word-link/edit/%'] = array(
    'title' => 'Edit word',
    'description' => 'Word edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_add_form', 5),
    'access arguments' => array('edit word link'),
    'type' => MENU_CALLBACK,
    'file' => 'word_link.admin.inc',
  );

  $items['admin/config/content/word-link/delete/%'] = array(
    'title' => 'Are you sure you want to delete this word?',
    'description' => 'Word delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_delete_form', 5),
    'access arguments' => array('delete word link'),
    'type' => MENU_CALLBACK,
    'file' => 'word_link.admin.inc',
  );

  $items['word-link/ajax/words'] = array(
    'page callback' => 'word_link_words_autocomplete_callback',
    'type' => MENU_CALLBACK,
    'access arguments' => array('create word link'),
  );

  $items['word-link/ajax/urls'] = array(
    'page callback' => 'word_link_urls_autocomplete_callback',
    'type' => MENU_CALLBACK,
    'access arguments' => array('create word link'),
  );

  return $items;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function word_link_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link to 'admin/config/content/word-link/add'
  // on 'admin/config/content/word-link/list' page.
  if ($root_path == 'admin/config/content/word-link') {
    $item = menu_get_item('admin/config/content/word-link/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Implements hook_init().
 */
function word_link_init() {
  // Add css if enabled.
  if (variable_get('word_link_add_css', 1)) {
    drupal_add_css(drupal_get_path('module', 'word_link') . '/css/word_link.css');
  }
}

/**
 * Implements hook_theme().
 */
function word_link_theme() {
  return array(
    'word_link' => array(
      'variables' => array(
        'text' => NULL,
        'tag' => NULL,
        'attributes' => array(),
      ),
      'file' => 'theme/word_link.theme.inc',
    ),
  );
}

/**
 * Implements hook_filter_info().
 */
function word_link_filter_info() {
  $filters['word_link'] = array(
    'title' => t('Word link'),
    'description' => t('Automatically converts words into links.'),
    'process callback' => '_word_link_process',
    'settings callback' => '_word_link_settings',
    'default settings' => array(
      'word_link_add_css' => TRUE,
      'word_link_highlight' => FALSE,
      'word_link_tags_except' => '<h1> <h2> <h3> <h4> <h5> <h6> <code>',
      'word_link_content_types' => array(),
    ),
    'weight' => 15,
  );
  return $filters;
}

/**
 * Implements callback_filter_settings().
 *
 * Filter settings callback for the Word Link filter.
 */
function _word_link_settings($form, &$form_state, $filter, $format, $defaults) {
  $filter->settings += $defaults;

  $settings['word_link_highlight'] = array(
    '#type' => 'checkbox',
    '#title' => t('Highlight words.'),
    '#description' => t('Highlight found words instead of replace it to links.'),
    '#default_value' => $filter->settings['word_link_highlight'],
  );
  $settings['word_link_tags_except'] = array(
    '#type' => 'textfield',
    '#title' => t('Disallowed HTML tags'),
    '#description' => t('A list of HTML tags that will be ignored. Never enter here tags that are not text. E.g. @tags.', array('@tags' => '<img>')),
    '#default_value' => $filter->settings['word_link_tags_except'],
  );
  $settings['word_link_content_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Content types'),
    '#description' => t('Choose content types in which words will be converted.'),
    '#options' => node_type_get_names(),
    '#default_value' => $filter->settings['word_link_content_types'],
  );

  return $settings;
}

/**
 * Helper function for filter process.
 */
function _word_link_process($text, $filter) {
  $words = word_link_load_all();
  if (!empty($words)) {
    $text = word_link_convert_text($words, $text, $filter->settings);
  }

  return $text;
}

/**
 * Find and convert defined word to link.
 *
 * @param array $words
 *   Array of words indexed by text.
 * @param string $text
 *   Input text.
 * @param array $settings
 *   Array of filter settings.
 *
 * @return string
 *   String with converted words.
 */
function word_link_convert_text($words, $text, $settings) {
  // Get current path. We need this to verify
  // if word will be converted on this page.
  $current_path = current_path();
  $args = arg();

  // Check if current node belongs to content type
  // in which need to convert words.
  // @todo: Need to check when node shows on another path.
  if (isset($args[0]) && $args[0] == 'node' && isset($args[1])) {
    $nodes = word_link_get_node_types();
    $type = isset($nodes[$args[1]]) ? $nodes[$args[1]]->type : NULL;

    if (in_array($type, $settings['word_link_content_types']) && !$settings['word_link_content_types'][$type]) {
      return $text;
    }
  }

  // Default HTML tag used in theme.
  $tag = 'a';

  // Get disallowed html tags and convert it for Xpath.
  if (!empty($settings['word_link_tags_except'])) {
    $disallowed_tags = preg_split('/\s+|<|>/', $settings['word_link_tags_except'], -1, PREG_SPLIT_NO_EMPTY);
    $disallowed = array();
    foreach ($disallowed_tags as $ancestor) {
      $disallowed[] = 'and not(ancestor::' . $ancestor . ')';
    }
    $disallowed = implode(' ', $disallowed);
  }

  // Create pattern.
  $path = drupal_strtolower(drupal_get_path_alias());
  $pattern = array();
  foreach ($words as $word) {
    $url = drupal_get_path_alias($word->url);
    $match = FALSE;

    // Check if current path matches word except path.
    if (!empty($word->except)) {
      $match = drupal_match_path($path, $word->except);
      if ($path != $current_path) {
        $match = $match || drupal_match_path($current_path, $word->except);
      }
    }

    // Get visibility status and check if need to convert word on this page.
    $visibility = empty($word->except) || !isset($word->visibility) ? FALSE : $word->visibility;

    if ($url != $path && !$match && !$visibility || $url != $path && $visibility && $match) {
      $text_lower = preg_replace('/\s+/', ' ', trim($word->text_lower));
      $pattern[] = preg_replace('/ /', '\\s+', preg_quote($text_lower));
    }
  }
  $pattern  = '/((\b)|(?<=))(' . implode('|', $pattern) . ')\b/ui';

  // Create DOM object.
  $dom = filter_dom_load($text);
  $xpath = new DOMXPath($dom);
  $text_nodes = $xpath->query('//text()[not(ancestor::a) ' . $disallowed . ']');

  foreach ($text_nodes as $original_node) {
    $text = $original_node->nodeValue;
    $match_count = preg_match_all($pattern, $text, $matches, PREG_OFFSET_CAPTURE);

    if ($match_count > 0) {
      $offset = 0;
      $parent = $original_node->parentNode;
      $next = $original_node->nextSibling;
      $parent->removeChild($original_node);

      foreach ($matches[0] as $delta => $match) {
        $match_text = $match[0];
        $match_pos = $match[1];
        $text_lower = drupal_strtolower($match_text);

        if (($words[$text_lower]->case_sensitive && $words[$text_lower]->text == $match_text) || !$words[$text_lower]->case_sensitive) {
          $prefix = substr($text, $offset, $match_pos - $offset);
          $parent->insertBefore($dom->createTextNode($prefix), $next);

          $link = $dom->createDocumentFragment();

          $target = url_is_external($words[$text_lower]->url) ? '_blank' : '';
          $attributes = array(
            'href' => url($words[$text_lower]->url),
            'title' => $words[$text_lower]->url_title,
            'class' => $words[$text_lower]->class,
            'target' => $target,
            'rel' => $words[$text_lower]->rel,
          );

          if ($settings['word_link_highlight']) {
            $tag = 'span';
            unset($attributes['href'], $attributes['target'], $attributes['rel']);
          }

          $link->appendXML(
            theme(
              'word_link',
              array(
                'text' => $match_text,
                'tag' => $tag,
                'attributes' => array_filter($attributes),
              )
            )
          );

          $parent->insertBefore($link, $next);

          $offset = $match_pos + strlen($match_text);

          if ($delta == $match_count - 1) {
            $suffix = substr($text, $offset);
            $parent->insertBefore($dom->createTextNode($suffix), $next);
          }
        }
        else {
          $parent->insertBefore($dom->createTextNode($text), $next);
        }
      }
    }
  }

  return filter_dom_serialize($dom);
}

/**
 * Gets all nodes and their types.
 *
 * @return mixed
 *   Array of nodes indexed by nid.
 */
function word_link_get_node_types() {
  $nodes = &drupal_static(__FUNCTION__);

  if (!isset($nodes)) {
    $query = db_select('node', 'n')
      ->fields('n', array('nid', 'type'));

    $nodes = $query->execute()->fetchAllAssoc('nid');
  }

  return $nodes;
}

/**
 * Loads words from the database.
 *
 * @return array
 *   An array of words objects indexed by text.
 */
function word_link_load_all() {
  $words = &drupal_static(__FUNCTION__);

  if (!isset($words)) {
    $query = db_select('word_link', 'wl');
    $query->addExpression('LOWER(wl.text)', 'text_lower');
    $query->fields('wl');
    $query->orderBy('wl.weight');
    $results = $query->execute();

    $words = array();
    foreach ($results as $word) {
      if (isset($words[$word->text_lower])) {
        if ($words[$word->text_lower]->weight >= $word->weight) {
          $words[$word->text_lower] = $word;
        }
      }
      else {
        $words[$word->text_lower] = $word;
      }
    }
  }

  return $words;
}

/**
 * Load link by its id.
 *
 * @param int $id
 *   The word ID.
 *
 * @return mixed
 *   A fully-populated word object, or FALSE if the word is not found.
 */
function word_link_load($id) {
  $word = &drupal_static(__FUNCTION__);

  if (!isset($words)) {
    $query = db_select('word_link', 'wl')
      ->fields('wl')
      ->condition('id', $id, '=');

    $word = $query->execute()->fetchAssoc();
    $word = $word ? (object) $word : $word;
  }

  return $word;
}

/**
 * Loads words from the database with pager.
 *
 * @param array $header
 *   (optional) header to build a table.
 * @param int $limit
 *   (optional) determines the number of fields to get.
 *
 * @return mixed
 *   An array of word objects indexed by id.
 */
function word_link_load_table($header = array(), $limit = NULL) {
  $words = &drupal_static(__FUNCTION__);

  if (!isset($words)) {
    $query = db_select('word_link', 'wl')
      ->extend('PagerDefault')
      ->limit($limit)
      ->extend('TableSort')
      ->orderByHeader($header)
      ->fields('wl');
    $words = $query->execute()->fetchAllAssoc('id');
  }

  return $words;
}

/**
 * Verify by text if link already exists.
 *
 * @param string $text
 *   Word text which need to find.
 * @param int $id
 *   (optional) ID of the word.
 *
 * @return bool
 *   Returns the word object if exist or FALSE if not.
 */
function word_link_exists($text, $id = 0) {
  $query = db_select('word_link', 'wl')
      ->fields('wl', array('text', 'case_sensitive', 'id'))
      ->condition('id', $id, '!=')
      ->condition('text', $text, '=');

  $word = $query->execute()->fetchAssoc();

  return $word ? (object) $word : $word;
}

/**
 * Add/Update link to the database.
 *
 * @param string $action
 *   Action which need to do.
 *   Can be 'insert' or 'update'.
 * @param array $values
 *   Array with values that need to process.
 * @param int $id
 *   (optional) ID of the word.
 *
 * @return mixed
 *   If the record insert or update failed, returns FALSE. If it succeeded,
 *   returns SAVED_NEW or SAVED_UPDATED, depending on the operation performed.
 */
function word_link_run_action($action, $values, $id = NULL) {
  if ($action == 'insert') {
    return drupal_write_record('word_link', $values);
  }
  elseif ($action == 'update') {
    $values['id'] = $id;
    return drupal_write_record('word_link', $values, 'id');
  }
}

/**
 * Delete link from the database.
 *
 * @param int $id
 *   ID of the word.
 */
function word_link_delete($id) {
  db_delete('word_link')->condition('id', $id)->execute();
}

/**
 * Autocomplete callback for words by text.
 *
 * @param string $string
 *   The string that will be searched.
 */
function word_link_words_autocomplete_callback($string = "") {
  $matches = array();
  if ($string) {
    $result = db_select('word_link', 'wl')
      ->fields('wl', array('id', 'text'))
      ->condition('text', db_like($string) . '%', 'LIKE')
      ->range(0, 10)
      ->execute();
    foreach ($result as $word) {
      $matches[$word->text . " ($word->id)"] = check_plain($word->text) . " ($word->id)";
    }
  }

  drupal_json_output($matches);
}

/**
 * Autocomplete callback for words by urls.
 *
 * @param string $string
 *   The string that will be searched.
 */
function word_link_urls_autocomplete_callback($string = "") {
  $matches = array();
  if ($string) {
    $node_query = db_select('node', 'n');
    $node_query->addField('n', 'nid', 'id');
    $node_query->addField('n', 'title', 'string');
    $node_query->condition('status', 1, '=');
    $node_query->condition('n.title', db_like($string) . '%', 'LIKE');
    $node_query->range(0, 10);
    $nodes = $node_query->execute()->fetchAllAssoc('id');

    $user_query = db_select('users', 'u');
    $user_query->addField('u', 'uid', 'id');
    $user_query->addField('u', 'name', 'string');
    $user_query->condition('status', 1, '=');
    $user_query->condition('u.name', db_like($string) . '%', 'LIKE');
    $user_query->range(0, 10);
    $users = $user_query->execute()->fetchAllAssoc('id');

    $term_query = db_select('taxonomy_term_data', 't');
    $term_query->addField('t', 'tid', 'id');
    $term_query->addField('t', 'name', 'string');
    $term_query->condition('t.name', db_like($string) . '%', 'LIKE');
    $term_query->range(0, 10);
    $terms = $term_query->execute()->fetchAllAssoc('id');

    $results = array(
      'node' => $nodes,
      'user' => $users,
      'taxonomy/term' => $terms,
    );

    foreach ($results as $path => $items) {
      foreach ($items as $item) {
        $matches[$path . '/' . $item->id] = check_plain($item->string) . " ($item->id)";
      }
    }
  }

  drupal_json_output($matches);
}
